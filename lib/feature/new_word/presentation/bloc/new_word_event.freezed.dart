// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'new_word_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$NewWordEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNewWords,
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNextNewWords,
    required TResult Function(String userId, NewWordModel word) addWordToUser,
    required TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)
        createWord,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNewWords,
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult? Function(String userId, NewWordModel word)? addWordToUser,
    TResult? Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(int userId, List<UserWordModel> userWordList)? getNewWords,
    TResult Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult Function(String userId, NewWordModel word)? addWordToUser,
    TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NewWord value) $default, {
    required TResult Function(GetNewWords value) getNewWords,
    required TResult Function(GetNextNewWords value) getNextNewWords,
    required TResult Function(AddWordToUser value) addWordToUser,
    required TResult Function(CreateWord value) createWord,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NewWord value)? $default, {
    TResult? Function(GetNewWords value)? getNewWords,
    TResult? Function(GetNextNewWords value)? getNextNewWords,
    TResult? Function(AddWordToUser value)? addWordToUser,
    TResult? Function(CreateWord value)? createWord,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NewWord value)? $default, {
    TResult Function(GetNewWords value)? getNewWords,
    TResult Function(GetNextNewWords value)? getNextNewWords,
    TResult Function(AddWordToUser value)? addWordToUser,
    TResult Function(CreateWord value)? createWord,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NewWordEventCopyWith<$Res> {
  factory $NewWordEventCopyWith(
          NewWordEvent value, $Res Function(NewWordEvent) then) =
      _$NewWordEventCopyWithImpl<$Res, NewWordEvent>;
}

/// @nodoc
class _$NewWordEventCopyWithImpl<$Res, $Val extends NewWordEvent>
    implements $NewWordEventCopyWith<$Res> {
  _$NewWordEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_NewWordCopyWith<$Res> {
  factory _$$_NewWordCopyWith(
          _$_NewWord value, $Res Function(_$_NewWord) then) =
      __$$_NewWordCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NewWordCopyWithImpl<$Res>
    extends _$NewWordEventCopyWithImpl<$Res, _$_NewWord>
    implements _$$_NewWordCopyWith<$Res> {
  __$$_NewWordCopyWithImpl(_$_NewWord _value, $Res Function(_$_NewWord) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_NewWord implements _NewWord {
  const _$_NewWord();

  @override
  String toString() {
    return 'NewWordEvent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NewWord);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNewWords,
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNextNewWords,
    required TResult Function(String userId, NewWordModel word) addWordToUser,
    required TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)
        createWord,
  }) {
    return $default();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNewWords,
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult? Function(String userId, NewWordModel word)? addWordToUser,
    TResult? Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
  }) {
    return $default?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(int userId, List<UserWordModel> userWordList)? getNewWords,
    TResult Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult Function(String userId, NewWordModel word)? addWordToUser,
    TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NewWord value) $default, {
    required TResult Function(GetNewWords value) getNewWords,
    required TResult Function(GetNextNewWords value) getNextNewWords,
    required TResult Function(AddWordToUser value) addWordToUser,
    required TResult Function(CreateWord value) createWord,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NewWord value)? $default, {
    TResult? Function(GetNewWords value)? getNewWords,
    TResult? Function(GetNextNewWords value)? getNextNewWords,
    TResult? Function(AddWordToUser value)? addWordToUser,
    TResult? Function(CreateWord value)? createWord,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NewWord value)? $default, {
    TResult Function(GetNewWords value)? getNewWords,
    TResult Function(GetNextNewWords value)? getNextNewWords,
    TResult Function(AddWordToUser value)? addWordToUser,
    TResult Function(CreateWord value)? createWord,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _NewWord implements NewWordEvent {
  const factory _NewWord() = _$_NewWord;
}

/// @nodoc
abstract class _$$GetNewWordsCopyWith<$Res> {
  factory _$$GetNewWordsCopyWith(
          _$GetNewWords value, $Res Function(_$GetNewWords) then) =
      __$$GetNewWordsCopyWithImpl<$Res>;
  @useResult
  $Res call({int userId, List<UserWordModel> userWordList});
}

/// @nodoc
class __$$GetNewWordsCopyWithImpl<$Res>
    extends _$NewWordEventCopyWithImpl<$Res, _$GetNewWords>
    implements _$$GetNewWordsCopyWith<$Res> {
  __$$GetNewWordsCopyWithImpl(
      _$GetNewWords _value, $Res Function(_$GetNewWords) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = null,
    Object? userWordList = null,
  }) {
    return _then(_$GetNewWords(
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as int,
      userWordList: null == userWordList
          ? _value._userWordList
          : userWordList // ignore: cast_nullable_to_non_nullable
              as List<UserWordModel>,
    ));
  }
}

/// @nodoc

class _$GetNewWords implements GetNewWords {
  _$GetNewWords(
      {required this.userId, required final List<UserWordModel> userWordList})
      : _userWordList = userWordList;

  @override
  final int userId;
  final List<UserWordModel> _userWordList;
  @override
  List<UserWordModel> get userWordList {
    if (_userWordList is EqualUnmodifiableListView) return _userWordList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userWordList);
  }

  @override
  String toString() {
    return 'NewWordEvent.getNewWords(userId: $userId, userWordList: $userWordList)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetNewWords &&
            (identical(other.userId, userId) || other.userId == userId) &&
            const DeepCollectionEquality()
                .equals(other._userWordList, _userWordList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, userId, const DeepCollectionEquality().hash(_userWordList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetNewWordsCopyWith<_$GetNewWords> get copyWith =>
      __$$GetNewWordsCopyWithImpl<_$GetNewWords>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNewWords,
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNextNewWords,
    required TResult Function(String userId, NewWordModel word) addWordToUser,
    required TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)
        createWord,
  }) {
    return getNewWords(userId, userWordList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNewWords,
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult? Function(String userId, NewWordModel word)? addWordToUser,
    TResult? Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
  }) {
    return getNewWords?.call(userId, userWordList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(int userId, List<UserWordModel> userWordList)? getNewWords,
    TResult Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult Function(String userId, NewWordModel word)? addWordToUser,
    TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
    required TResult orElse(),
  }) {
    if (getNewWords != null) {
      return getNewWords(userId, userWordList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NewWord value) $default, {
    required TResult Function(GetNewWords value) getNewWords,
    required TResult Function(GetNextNewWords value) getNextNewWords,
    required TResult Function(AddWordToUser value) addWordToUser,
    required TResult Function(CreateWord value) createWord,
  }) {
    return getNewWords(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NewWord value)? $default, {
    TResult? Function(GetNewWords value)? getNewWords,
    TResult? Function(GetNextNewWords value)? getNextNewWords,
    TResult? Function(AddWordToUser value)? addWordToUser,
    TResult? Function(CreateWord value)? createWord,
  }) {
    return getNewWords?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NewWord value)? $default, {
    TResult Function(GetNewWords value)? getNewWords,
    TResult Function(GetNextNewWords value)? getNextNewWords,
    TResult Function(AddWordToUser value)? addWordToUser,
    TResult Function(CreateWord value)? createWord,
    required TResult orElse(),
  }) {
    if (getNewWords != null) {
      return getNewWords(this);
    }
    return orElse();
  }
}

abstract class GetNewWords implements NewWordEvent {
  factory GetNewWords(
      {required final int userId,
      required final List<UserWordModel> userWordList}) = _$GetNewWords;

  int get userId;
  List<UserWordModel> get userWordList;
  @JsonKey(ignore: true)
  _$$GetNewWordsCopyWith<_$GetNewWords> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetNextNewWordsCopyWith<$Res> {
  factory _$$GetNextNewWordsCopyWith(
          _$GetNextNewWords value, $Res Function(_$GetNextNewWords) then) =
      __$$GetNextNewWordsCopyWithImpl<$Res>;
  @useResult
  $Res call({int userId, List<UserWordModel> userWordList});
}

/// @nodoc
class __$$GetNextNewWordsCopyWithImpl<$Res>
    extends _$NewWordEventCopyWithImpl<$Res, _$GetNextNewWords>
    implements _$$GetNextNewWordsCopyWith<$Res> {
  __$$GetNextNewWordsCopyWithImpl(
      _$GetNextNewWords _value, $Res Function(_$GetNextNewWords) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = null,
    Object? userWordList = null,
  }) {
    return _then(_$GetNextNewWords(
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as int,
      userWordList: null == userWordList
          ? _value._userWordList
          : userWordList // ignore: cast_nullable_to_non_nullable
              as List<UserWordModel>,
    ));
  }
}

/// @nodoc

class _$GetNextNewWords implements GetNextNewWords {
  _$GetNextNewWords(
      {required this.userId, required final List<UserWordModel> userWordList})
      : _userWordList = userWordList;

  @override
  final int userId;
  final List<UserWordModel> _userWordList;
  @override
  List<UserWordModel> get userWordList {
    if (_userWordList is EqualUnmodifiableListView) return _userWordList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userWordList);
  }

  @override
  String toString() {
    return 'NewWordEvent.getNextNewWords(userId: $userId, userWordList: $userWordList)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetNextNewWords &&
            (identical(other.userId, userId) || other.userId == userId) &&
            const DeepCollectionEquality()
                .equals(other._userWordList, _userWordList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, userId, const DeepCollectionEquality().hash(_userWordList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetNextNewWordsCopyWith<_$GetNextNewWords> get copyWith =>
      __$$GetNextNewWordsCopyWithImpl<_$GetNextNewWords>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNewWords,
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNextNewWords,
    required TResult Function(String userId, NewWordModel word) addWordToUser,
    required TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)
        createWord,
  }) {
    return getNextNewWords(userId, userWordList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNewWords,
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult? Function(String userId, NewWordModel word)? addWordToUser,
    TResult? Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
  }) {
    return getNextNewWords?.call(userId, userWordList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(int userId, List<UserWordModel> userWordList)? getNewWords,
    TResult Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult Function(String userId, NewWordModel word)? addWordToUser,
    TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
    required TResult orElse(),
  }) {
    if (getNextNewWords != null) {
      return getNextNewWords(userId, userWordList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NewWord value) $default, {
    required TResult Function(GetNewWords value) getNewWords,
    required TResult Function(GetNextNewWords value) getNextNewWords,
    required TResult Function(AddWordToUser value) addWordToUser,
    required TResult Function(CreateWord value) createWord,
  }) {
    return getNextNewWords(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NewWord value)? $default, {
    TResult? Function(GetNewWords value)? getNewWords,
    TResult? Function(GetNextNewWords value)? getNextNewWords,
    TResult? Function(AddWordToUser value)? addWordToUser,
    TResult? Function(CreateWord value)? createWord,
  }) {
    return getNextNewWords?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NewWord value)? $default, {
    TResult Function(GetNewWords value)? getNewWords,
    TResult Function(GetNextNewWords value)? getNextNewWords,
    TResult Function(AddWordToUser value)? addWordToUser,
    TResult Function(CreateWord value)? createWord,
    required TResult orElse(),
  }) {
    if (getNextNewWords != null) {
      return getNextNewWords(this);
    }
    return orElse();
  }
}

abstract class GetNextNewWords implements NewWordEvent {
  factory GetNextNewWords(
      {required final int userId,
      required final List<UserWordModel> userWordList}) = _$GetNextNewWords;

  int get userId;
  List<UserWordModel> get userWordList;
  @JsonKey(ignore: true)
  _$$GetNextNewWordsCopyWith<_$GetNextNewWords> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddWordToUserCopyWith<$Res> {
  factory _$$AddWordToUserCopyWith(
          _$AddWordToUser value, $Res Function(_$AddWordToUser) then) =
      __$$AddWordToUserCopyWithImpl<$Res>;
  @useResult
  $Res call({String userId, NewWordModel word});
}

/// @nodoc
class __$$AddWordToUserCopyWithImpl<$Res>
    extends _$NewWordEventCopyWithImpl<$Res, _$AddWordToUser>
    implements _$$AddWordToUserCopyWith<$Res> {
  __$$AddWordToUserCopyWithImpl(
      _$AddWordToUser _value, $Res Function(_$AddWordToUser) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userId = null,
    Object? word = null,
  }) {
    return _then(_$AddWordToUser(
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as NewWordModel,
    ));
  }
}

/// @nodoc

class _$AddWordToUser implements AddWordToUser {
  _$AddWordToUser({required this.userId, required this.word});

  @override
  final String userId;
  @override
  final NewWordModel word;

  @override
  String toString() {
    return 'NewWordEvent.addWordToUser(userId: $userId, word: $word)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddWordToUser &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.word, word) || other.word == word));
  }

  @override
  int get hashCode => Object.hash(runtimeType, userId, word);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddWordToUserCopyWith<_$AddWordToUser> get copyWith =>
      __$$AddWordToUserCopyWithImpl<_$AddWordToUser>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNewWords,
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNextNewWords,
    required TResult Function(String userId, NewWordModel word) addWordToUser,
    required TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)
        createWord,
  }) {
    return addWordToUser(userId, word);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNewWords,
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult? Function(String userId, NewWordModel word)? addWordToUser,
    TResult? Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
  }) {
    return addWordToUser?.call(userId, word);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(int userId, List<UserWordModel> userWordList)? getNewWords,
    TResult Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult Function(String userId, NewWordModel word)? addWordToUser,
    TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
    required TResult orElse(),
  }) {
    if (addWordToUser != null) {
      return addWordToUser(userId, word);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NewWord value) $default, {
    required TResult Function(GetNewWords value) getNewWords,
    required TResult Function(GetNextNewWords value) getNextNewWords,
    required TResult Function(AddWordToUser value) addWordToUser,
    required TResult Function(CreateWord value) createWord,
  }) {
    return addWordToUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NewWord value)? $default, {
    TResult? Function(GetNewWords value)? getNewWords,
    TResult? Function(GetNextNewWords value)? getNextNewWords,
    TResult? Function(AddWordToUser value)? addWordToUser,
    TResult? Function(CreateWord value)? createWord,
  }) {
    return addWordToUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NewWord value)? $default, {
    TResult Function(GetNewWords value)? getNewWords,
    TResult Function(GetNextNewWords value)? getNextNewWords,
    TResult Function(AddWordToUser value)? addWordToUser,
    TResult Function(CreateWord value)? createWord,
    required TResult orElse(),
  }) {
    if (addWordToUser != null) {
      return addWordToUser(this);
    }
    return orElse();
  }
}

abstract class AddWordToUser implements NewWordEvent {
  factory AddWordToUser(
      {required final String userId,
      required final NewWordModel word}) = _$AddWordToUser;

  String get userId;
  NewWordModel get word;
  @JsonKey(ignore: true)
  _$$AddWordToUserCopyWith<_$AddWordToUser> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateWordCopyWith<$Res> {
  factory _$$CreateWordCopyWith(
          _$CreateWord value, $Res Function(_$CreateWord) then) =
      __$$CreateWordCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String category,
      String example,
      String word,
      String pronuntiationLink,
      String pronuntiationText,
      List<WordActivity> activityList});
}

/// @nodoc
class __$$CreateWordCopyWithImpl<$Res>
    extends _$NewWordEventCopyWithImpl<$Res, _$CreateWord>
    implements _$$CreateWordCopyWith<$Res> {
  __$$CreateWordCopyWithImpl(
      _$CreateWord _value, $Res Function(_$CreateWord) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? category = null,
    Object? example = null,
    Object? word = null,
    Object? pronuntiationLink = null,
    Object? pronuntiationText = null,
    Object? activityList = null,
  }) {
    return _then(_$CreateWord(
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      example: null == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String,
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as String,
      pronuntiationLink: null == pronuntiationLink
          ? _value.pronuntiationLink
          : pronuntiationLink // ignore: cast_nullable_to_non_nullable
              as String,
      pronuntiationText: null == pronuntiationText
          ? _value.pronuntiationText
          : pronuntiationText // ignore: cast_nullable_to_non_nullable
              as String,
      activityList: null == activityList
          ? _value._activityList
          : activityList // ignore: cast_nullable_to_non_nullable
              as List<WordActivity>,
    ));
  }
}

/// @nodoc

class _$CreateWord implements CreateWord {
  _$CreateWord(
      {required this.category,
      required this.example,
      required this.word,
      required this.pronuntiationLink,
      required this.pronuntiationText,
      required final List<WordActivity> activityList})
      : _activityList = activityList;

  @override
  final String category;
  @override
  final String example;
  @override
  final String word;
  @override
  final String pronuntiationLink;
  @override
  final String pronuntiationText;
  final List<WordActivity> _activityList;
  @override
  List<WordActivity> get activityList {
    if (_activityList is EqualUnmodifiableListView) return _activityList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_activityList);
  }

  @override
  String toString() {
    return 'NewWordEvent.createWord(category: $category, example: $example, word: $word, pronuntiationLink: $pronuntiationLink, pronuntiationText: $pronuntiationText, activityList: $activityList)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateWord &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.word, word) || other.word == word) &&
            (identical(other.pronuntiationLink, pronuntiationLink) ||
                other.pronuntiationLink == pronuntiationLink) &&
            (identical(other.pronuntiationText, pronuntiationText) ||
                other.pronuntiationText == pronuntiationText) &&
            const DeepCollectionEquality()
                .equals(other._activityList, _activityList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      category,
      example,
      word,
      pronuntiationLink,
      pronuntiationText,
      const DeepCollectionEquality().hash(_activityList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateWordCopyWith<_$CreateWord> get copyWith =>
      __$$CreateWordCopyWithImpl<_$CreateWord>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNewWords,
    required TResult Function(int userId, List<UserWordModel> userWordList)
        getNextNewWords,
    required TResult Function(String userId, NewWordModel word) addWordToUser,
    required TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)
        createWord,
  }) {
    return createWord(category, example, word, pronuntiationLink,
        pronuntiationText, activityList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNewWords,
    TResult? Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult? Function(String userId, NewWordModel word)? addWordToUser,
    TResult? Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
  }) {
    return createWord?.call(category, example, word, pronuntiationLink,
        pronuntiationText, activityList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(int userId, List<UserWordModel> userWordList)? getNewWords,
    TResult Function(int userId, List<UserWordModel> userWordList)?
        getNextNewWords,
    TResult Function(String userId, NewWordModel word)? addWordToUser,
    TResult Function(
            String category,
            String example,
            String word,
            String pronuntiationLink,
            String pronuntiationText,
            List<WordActivity> activityList)?
        createWord,
    required TResult orElse(),
  }) {
    if (createWord != null) {
      return createWord(category, example, word, pronuntiationLink,
          pronuntiationText, activityList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_NewWord value) $default, {
    required TResult Function(GetNewWords value) getNewWords,
    required TResult Function(GetNextNewWords value) getNextNewWords,
    required TResult Function(AddWordToUser value) addWordToUser,
    required TResult Function(CreateWord value) createWord,
  }) {
    return createWord(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_NewWord value)? $default, {
    TResult? Function(GetNewWords value)? getNewWords,
    TResult? Function(GetNextNewWords value)? getNextNewWords,
    TResult? Function(AddWordToUser value)? addWordToUser,
    TResult? Function(CreateWord value)? createWord,
  }) {
    return createWord?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_NewWord value)? $default, {
    TResult Function(GetNewWords value)? getNewWords,
    TResult Function(GetNextNewWords value)? getNextNewWords,
    TResult Function(AddWordToUser value)? addWordToUser,
    TResult Function(CreateWord value)? createWord,
    required TResult orElse(),
  }) {
    if (createWord != null) {
      return createWord(this);
    }
    return orElse();
  }
}

abstract class CreateWord implements NewWordEvent {
  factory CreateWord(
      {required final String category,
      required final String example,
      required final String word,
      required final String pronuntiationLink,
      required final String pronuntiationText,
      required final List<WordActivity> activityList}) = _$CreateWord;

  String get category;
  String get example;
  String get word;
  String get pronuntiationLink;
  String get pronuntiationText;
  List<WordActivity> get activityList;
  @JsonKey(ignore: true)
  _$$CreateWordCopyWith<_$CreateWord> get copyWith =>
      throw _privateConstructorUsedError;
}
